<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/me319/libs/katex/katex.min.css"> <link rel=stylesheet  href="/me319/libs/highlight/github.min.css"> <link rel=stylesheet  href="/me319/css/franklin.css"> <link rel=stylesheet  href="/me319/css/poole_hyde.css"> <link rel=stylesheet  href="/me319/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 968px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/me319/assets/c.svg"> <title>Part I L5 - GPIO</title> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <img src="/me319/assets/KuwaitUniversityLogoTextLight.svg" style="width: 200px; height: auto; display: inline"> <h1 style="font-size:2em; opacity: 0.75;"><a href="/me319/">ME 319</a></h1> <p class=lead >Mechatronics</p> </div> <script> function hidePart(part_div) { var x = document.getElementById(part_div); if (x.style.display === "none") { x.style.display = "block"; } else { x.style.display = "none"; } } </script> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/me319/">Home</a> <a class="sidebar-nav-item " href="/me319/videos/">Lecture Videos</a> <a class="sidebar-nav-item " href="https://alsaibie.github.io/embedded_ccpp">Embedded C/C++ Mini-Course</a> <a class="sidebar-nav-item " href="/me319/lab_assignments/">Lab Assignments</a> <br> <small style="text-transform: uppercase; font-size: 0.75em">Lab Lessons</small> <div class=part  onclick="hidePart('prelabs_div')">Prelabs</div> <div id=prelabs_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/prelabs/prelab2/"><b>Lab 2</b> - <em>PlatformIO and Arduino</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab3/"><b>Lab 3</b> - <em>Debugging and LL Programming</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab4/"><b>Lab 4</b> - <em>Timers and Interrupts</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab5/"><b>Lab 5</b> - <em>Serial Communication</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab6/"><b>Lab 6</b> - <em>Offline Digital Filtering</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab7/"><b>Lab 7</b> - <em>Online Digital Filtering</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab8/"><b>Lab 8</b> - <em>Motor Dynamics and Control</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab9/"><b>Lab 9</b> - <em>Realtime Motor Control</em></a> </div> <div class=part  onclick="hidePart('addlessons_div')">Additional Lessons</div> <div id=addlessons_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/prelabsextra/lab4extra/"> <b>L4E</b> - <em>Low Level Timers Configuration</em></a> </div> <br> <small style="text-transform: uppercase; font-size: 0.75em">Class Lectures</small> <div class=part  onclick="hidePart('part1_div')">I The Brain</div> <div id=part1_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_i/lecture0/"><b>L0</b> - <em>Introduction</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture1/"><b>L1</b> - <em>Microcontroller Architecture</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture2/"><b>L2</b> - <em>Digital Arithmetic</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture3/"><b>L3</b> - <em>Digital Logic</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture4/"><b>L4</b> - <em>Microcontroller Peripherals</em></a> <a class="sidebar-nav-item active" href="/me319/part_i/lecture5/"><b>L5</b> - <em>GPIO</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture6/"><b>L6</b> - <em>Timers</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture7/"><b>L7</b> - <em>Interrupts</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture8/"><b>L8</b> - <em>Communication</em></a> </div> <div class=part  onclick="hidePart('part2_div')">II The Cells</div> <div id=part2_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_ii/lecture1/"><b>L1</b> - <em>Passive Circuits</em></a> <a class="sidebar-nav-item " href="/me319/part_ii/lecture2/"><b>L2</b> - <em>Switching Semiconductors</em></a> <a class="sidebar-nav-item " href="/me319/part_ii/lecture3/"><b>L3</b> - <em>Operational Amplifiers</em></a> </div> <div class=part  onclick="hidePart('part3_div')">III The Senses</div> <div id=part3_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_iii/lecture1/"><b>L1</b> - <em>Signal Conditioning and Filtering</em></a> <a class="sidebar-nav-item " href="/me319/part_iii/lecture2/"><b>L2</b> - <em>Sensor Charactersitics</em></a> <a class="sidebar-nav-item " href="/me319/part_iii/lecture3/"><b>L3</b> - <em>Survey of Sensors</em></a> <a class="sidebar-nav-item " href="/me319/part_iii/lecture4/"><b>L4</b> - <em>Motion Sensors</em></a> </div> <div class=part  onclick="hidePart('part4_div')">IV The Muscles</div> <div id=part4_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_iv/lecture1/"><b>L1</b> - <em>DC Motors</em></a> <a class="sidebar-nav-item " href="/me319/part_iv/lecture2/"><b>L2</b> - <em>Practical Feedback Control</em></a> <a class="sidebar-nav-item " href="/me319/part_iv/lecture4/"><b>L3</b> - <em>Stepper Motors</em></a> </div> <div class=part  onclick="hidePart('part5_div')">V The Body</div> <div id=part5_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_v/lecture1/"><b>L1</b> - <em>System Integration</em></a> </div> </nav> <p>&copy; Ali AlSaibie, PhD.</p> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=part_i_l5_-_general_purpose_input_output ><a href="#part_i_l5_-_general_purpose_input_output" class=header-anchor >Part I L5 - General Purpose Input Output</a></h1> <h2 id=lecture_video ><a href="#lecture_video" class=header-anchor >Lecture Video</a></h2> <p> <iframe src="https://player.vimeo.com/video/540099285" width=780  height=438  frameborder=0  allowfullscreen></iframe> <a href="/me319/part_i/ME319_-_Mechatronics_-_Part_I_Lecture_5_GPIO.pdf">Lecture Handout</a></p> <p>Next: <a href="../lecture6/">Part I L6 - Timers</a> </p> <h2 id=objectives ><a href="#objectives" class=header-anchor >Objectives</a></h2> <ul> <li><p>Review the basic components of the GPIO Peripheral</p> <li><p>Become familiar with the microcontroller reference manual</p> <li><p>Walk through a blinky routine at different abstraction levels</p> </ul> <h3 id=what_is_a_gpio ><a href="#what_is_a_gpio" class=header-anchor >What is a GPIO</a></h3> <p>GPIO, which stands for General Purpose Input Output, provides a basic way to interface the MCU with the outside world. It&#39;s a name of a peripheral that allows for setting pin directions is input or output, it allows for setting the value of output pins, Logic High or Logic Low, and it allows for reading the state of input pins. </p> <p>GPIO Pins belong to Ports, On STM32F401x there are up to 16 pins per port On STM32F401x, most pins are GPIO by default &#40;on reset&#41;, some pins are set for special functions on reset &#40;JTAG&#41;. All input pins are 5V-Tolerant even though the MCU operates on 3.3V. There are 15 GPIO Blocks. Ports A - Port Q &#91;No Port I or Port O&#93;, each pin has an internal optional weak pull-up or pull-down resisters.</p> <h3 id=example ><a href="#example" class=header-anchor >Example </a></h3> <center><img src="/me319/part_i/lecture5_media/GPIOExampleLEDSwitch.svg" style="max-width:425px"></center> <p>Pin PA1 and PA0 are both configured as GPIO pins. </p> <p>PA1 is read as &quot;Port A Pin 1&quot;, and similarly PA0 is read &quot;Port A Pin 0&quot; PA1 is set as an output pin while PA0 as set as an input pin.</p> <p>When PA1 is set High &#40;Logic 1&#41; the <strong>LED</strong> turns on. And when the switch <strong>SW</strong> is pressed, pin PA0 reads logic 1 &#40;High&#41;. An output pin is <strong>set</strong> and an input pin is <strong>read</strong>. The GPIO Peripheral usually has multiple ports, which have multiple pins.</p> <h2 id=alternate_functions ><a href="#alternate_functions" class=header-anchor >Alternate Functions</a></h2> <p>GPIO Pins also refer to programmable pins in general &#40;non-fixed func pins: GND, 5V, etc&#41;, so every pin that is programmed for a general GPIO or other peripheral function is still referred to as a GPIO pin. GPIO pins can be configured for alternative functions such as: UART,I2C,ADC,DAC etc. Table 9 in the datasheet lists the alternate functions each pin can have. A has a physical identification on the MCU package and it can only serve one function at a time. E.g. Pins PA0 and PA1 can have one of 4 alternative digital functions:</p> <ol> <li><p>Timer2 Ch 1</p> <li><p>Timer 5 Ch 2</p> <li><p>USART Clear To Send</p> <li><p>or Event Out &#40;Interrupt Pin&#41; </p> </ol> <center><img src="/me319/part_i/lecture5_media/Table9Datasheet_AltFunctions.svg" style="max-width:780px"></center> <h2 id=current_capabilities ><a href="#current_capabilities" class=header-anchor >Current Capabilities</a></h2> <p>Pins can drive low current external devices, such as LEDs or other integrated circuits, they are not capable of driving higher load devices. A GPIO pin on an MCU can not provide enough current to light a 60W light bulb or turn even a small DC motor. <center><img src="/me319/part_i/lecture5_media/Table12Datasheet_ElectricalChar.svg" style="max-width:780px"></center></p> <p>To drive high current devices such as a light bulb, an external driver is required. The pin signal from the MCU acts as a trigger to the switch. E.g. Use a transistor to light LED. The transistor is turned &quot;on&quot; or &quot;off&quot; by the signal from the MCU, but the current passing through the LED from the power supply does not go through the MCU. The idea is similar when using electrical relay switches. You can use multiple GPIO pins to control your home windows shutter with the help of electrical relays. </p> <center><img src="/me319/part_i/lecture5_media/GPIOExampleLEDSwitch.svg" style="max-width:425px"></center> <h2 id=pull-down_and_pull-up_resistors ><a href="#pull-down_and_pull-up_resistors" class=header-anchor >Pull-down and Pull-Up Resistors</a></h2> <p>To ensure deterministic binary logic, a pull up or pull down resistor is used. The resistor guarantees the logic is inverted when the source is not connected, and that the value is not “floating”.</p> <p>Consider the switch above connected to PA0. When the switch is not pressed, the path of least resistance is through the resistor R2 guaranteeing that the signal will be connected to ground &#40;Logic Low, or 0&#41; and when the switch is pressed, the path of least resistance is through the switch and not the resistor R2 and the signal is then guaranteed to equal <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">V_s</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> &#40;Logic High, or 1&#41;. This resistor is called a pull-down resistor, it &quot;pulls&quot; the signal down to ground making it normally low. </p> <p>Positive Logic: Pin normally connected to ground through pull-down resistor, so pin reads low. When source is connected, pin reads high.</p> <p>Negative Logic: Pin normally connected to source through pull-up resistor, connecting to ground sets pin low.</p> <p>Weak:- high resistance &#40;weak current drain&#41;</p> <center><img src="/me319/part_i/lecture5_media/PullResistors.svg" style="max-width:525px"></center> <h2 id=microcontroller_registers_-_an_overview ><a href="#microcontroller_registers_-_an_overview" class=header-anchor >Microcontroller Registers - An Overview</a></h2> <p>Program code interacts with hardware through changing bits inside registers. A register is a memory location inside the microcontroller. Interface with the outside world on a microcontroller is done through registers, whether reading or writing to them. Registers can be Read-Only, or Read-Write. The STM32F401RE is a 32bit microcontroller, and so each register is technically composed of 32 bit-fields. But not all registers use the full 32-bit space. </p> <p>A typical register address looks like <strong>0x4002 0000</strong></p> <p>The above happens to be the base address for GPIO Port A. Reading a datasheet, you will find that GPIO registers are listed by their offset from some base address.</p> <h2 id=example_register ><a href="#example_register" class=header-anchor >Example Register</a></h2> <p>Each GPIO peripheral &#40;port&#41; has a similar set of registers. Here is one common register to every GPIO port, the <strong>GPIO Mode Register</strong>. It is used to set the mode of each pin. Note that two bits are required here to set the mode of the pin belonging to that register. <center><img src="/me319/part_i/lecture5_media/Register_GPIOMODER.svg" style="max-width:785px"></center></p> <blockquote> <p>Example: we write 01 in bits &#91;11:10&#93; if we want to set Pin 5 as an output pin. This is basically what the Arduino function: <strong>pinMode&#40;PA5, OUTPUT&#41;;</strong> does</p> </blockquote> <h2 id=register_addressing ><a href="#register_addressing" class=header-anchor >Register: Addressing</a></h2> <p>On STM32 MCUs, a base address is given for a peripheral and then the list offsets from that address for each register. Given GPIO Port A base address: 0x4002 0000. The GPIOs mode registers &#40;GPIOx&#95;MODER&#41; address offset is 0x00, and the output data register &#40;GPIOx&#95;ODR&#41; address offset is 0x14 Then: GPIO mode register address for Port A &#40;GPIOA&#95;MODER&#41; is then:</p> <p><strong>0x4002 0000 &#40;&#61; 0x4002 0000 &#43; 0x00&#41;</strong></p> <p>GPIO output type register address for Port A &#40;GPIOA&#95;ODR&#41; is then</p> <p><strong>0x4002 0014 &#40;&#61; 0x4002 0000 &#43; 0x14&#41;</strong></p> <p>If the base address of GPIO Port B is: 0x40020400, What is the GPIOB&#95;ODR address?</p> <h2 id=blinky_example_on_stm32nucleo ><a href="#blinky_example_on_stm32nucleo" class=header-anchor >Blinky Example on STM32Nucleo</a></h2> <p>To execute a basic blinky routine without using any library, and by direct accesss to registers, we need to do the following on STM32F401RE. The LED is connected to PA5: Port A Pin 5</p> <ol> <li><p>Enable the GPIO Port A clock, in effect turning on the GPIO Port &#40;See RCC Register&#41;</p> <li><p>Set the GPIO Port A Pin 5 as output &#40;See GPIOA_MODER Register&#41;</p> <li><p>Set the GPIO Port A Pin 5 output to 1 &#40;High&#41; to turn LED On, or set it to 0 &#40;Low&#41; to switch it off</p> <li><p>Have some delay routine in between the Ons and Offs</p> </ol> <p>Let’s see the relevant registers and see how we can execute a blinky code. The concepts learned will extend to advanced peripherals.</p> <h3 id=rcc_register ><a href="#rcc_register" class=header-anchor >RCC Register</a></h3> <p>RCC which stands Reset and Clock Control with a base address: 0x4002 3800. This register is specific to peripherals, and it needs to be configured in order to enable &#40;turn on&#41; the GPIO port. By default, peripherals are switched off &#40;clock source to peripheral disabled&#41;. We can turn each peripheral clock on/off separately. </p> <p>Specifically, the RCC_AHB1 peripheral clock enable register is where GPIO Port A is enabled. <center><img src="/me319/part_i/lecture5_media/Register_RCCABHR.svg" style="max-width:785px"></center></p> <h3 id=gpio_mode_register ><a href="#gpio_mode_register" class=header-anchor >GPIO Mode Register</a></h3> <p>Through the GPIO Mode register we set individual pins either as: Input, Output, Analog or Alternate Function &#40;AF, e.g. UART, USB, PWM, TIM, etc&#41;</p> <center><img src="/me319/part_i/lecture5_media/Register_GPIOMODER.svg" style="max-width:785px"></center> <h3 id=gpio_odr_register ><a href="#gpio_odr_register" class=header-anchor >GPIO ODR Register</a></h3> <p>ODR, which stands for Output Data Register. This register is manipulated in order to set pins high or low, in effect turning the LED on and off. Note that all the pins of a specific GPIO port are set through the 16-bits of the GPIO port&#39;s ODR register. For example the ODR register for GPIO port A is referred to as GPIO<strong>A</strong>&#95;ODR and it has an address </p> <p><strong>0x4002 0014 &#40;&#61; 0x4002 0000 &#43; 0x14&#41;</strong> <center><img src="/me319/part_i/lecture5_media/Register_GPIOODR.svg" style="max-width:785px"></center></p> <h3 id=gpio_idr_register ><a href="#gpio_idr_register" class=header-anchor >GPIO IDR Register</a></h3> <p>There are other registers for manipulating GPIO, which you can review on the Reference Manual &#40;<a href="/me319/assets/reference_docs/REF02_STM32F401xBC_and_STM32F401xDE_Reference_Manual.pdf">REF02</a>&#41; Here, GPIO_IDR is the GPIO Input Data Register for example, which is where you would read the state of an <em>input</em> pin. </p> <center><img src="/me319/part_i/lecture5_media/Register_GPIOIDR.svg" style="max-width:785px"></center> <h3 id=gpio_registers ><a href="#gpio_registers" class=header-anchor >GPIO Registers</a></h3> <p>Here is a summary of the GPIO registers available on STM32F401RE</p> <ul> <li><p>GPIOx_MODER</p> <ul> <li><p>Mode Register &#40;Input, Output, AF, Analog&#41;</p> </ul> <li><p>GPIOx_OTYPER</p> <ul> <li><p>Output Type &#40;Push-pull or Open-drain&#41;</p> </ul> <li><p>GPIOx_OSPEEDR</p> <ul> <li><p>Output Speed &#40;Low, Medium, High, Very High Speed&#41;</p> </ul> <li><p>GPIOx_PUPDR</p> <ul> <li><p>Pull-up/Pull-down Register</p> </ul> <li><p>GPIOx_IDR</p> <ul> <li><p>Input Data Register</p> </ul> <li><p>GPIOx_ODR</p> <ul> <li><p>Output Data Register</p> </ul> <li><p>GPIOx_BSRR</p> <ul> <li><p>Bit Set / Reset</p> </ul> <li><p>GPIOx_LCKR</p> <ul> <li><p>Port Configuration Lock</p> </ul> <li><p>GPIOx_AFRL</p> <ul> <li><p>Alternate Function Low Register</p> </ul> <li><p>GPIOx_AFRH</p> <ul> <li><p>Alternate Function High Register</p> </ul> </ul> <h2 id=headerless_blinky_example_on_stm32nucleo ><a href="#headerless_blinky_example_on_stm32nucleo" class=header-anchor >Headerless Blinky Example on STM32Nucleo</a></h2> <p>In C, this is the code to perform a blinky routine. Program Size: 220 Bytes</p> <pre><code class="cpp hljs"><span class=hljs-comment >/* Look Ma!, no headers */</span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >define</span> GPIOARCCR (*(volatile int *)(0x40023800 + 0x30))</span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >define</span> GPIOAMODER (*(volatile int *)0x40020000)</span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >define</span> GPIOAODR (*(volatile int *)(0x40020000 + 0x14))</span>

<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >void</span>)</span> </span>{
    <span class=hljs-comment >/* Enable GPIOA Clock */</span>
    GPIOARCCR |= <span class=hljs-number >1</span>; <span class=hljs-comment >/* Ref RCC_AHB2ENR register */</span>
    <span class=hljs-comment >/* Set Port A Pin 5 as Output */</span> 
    GPIOAMODER |= (<span class=hljs-number >1</span> &lt;&lt; <span class=hljs-number >10</span>); <span class=hljs-comment >/* Ref GPIOx_MODER register */</span>
    <span class=hljs-keyword >while</span> (<span class=hljs-number >1</span>) {
        <span class=hljs-comment >/* Set LED Pin High */</span>
        GPIOAODR |= (<span class=hljs-number >1</span> &lt;&lt; <span class=hljs-number >5</span>); <span class=hljs-comment >/* Ref GPIOx_ODR register*/</span>
        <span class=hljs-comment >/* Dumb Delay: wait x number of clock cycles */</span>
        <span class=hljs-keyword >for</span> (<span class=hljs-keyword >int</span> k = <span class=hljs-number >0</span>; k&lt;<span class=hljs-number >1000000</span>; k++){__asm(<span class=hljs-string >&quot;nop&quot;</span>);}
        <span class=hljs-comment >/* Set LED Pin Low */</span>
        GPIOAODR &amp;= ~(<span class=hljs-number >1</span> &lt;&lt; <span class=hljs-number >5</span>); <span class=hljs-comment >/* Ref GPIOx_ODR register*/</span>
        <span class=hljs-comment >/* Dumb Delay */</span>
        <span class=hljs-keyword >for</span> (<span class=hljs-keyword >int</span> k = <span class=hljs-number >0</span>; k&lt;<span class=hljs-number >1000000</span>; k++){__asm(<span class=hljs-string >&quot;nop&quot;</span>);}
    }
}</code></pre> <blockquote> <p>This is the lowest level programming in C, any lower and you will have to program in assembly. Not portable to other MCUs in the same family </p> </blockquote> <h2 id=register_address_addressing ><a href="#register_address_addressing" class=header-anchor >Register Address Addressing</a></h2> <p>What is this gibberish? <code>#define GPIOAODR &#40;*&#40;volatile int *&#41;&#40;0x40020000 &#43; 0x14&#41;&#41;</code> ?</p> <p>This is creating a macro: GPIOAODR to access the GPIO Port A Output Data R The address itself is 0x40020014, but in C/C&#43;&#43; this is just a number, so we need to tell the compiler that we want to represent and access the value <strong>in</strong> that <strong>address</strong>, so, in order to do that we have to: </p> <ol> <li><p>Cast the hex number to 32bit pointer, now we have a pointer &#40;address only&#41;</p> <ul> <li><p><code>#define GPIOAODR &#40;int *&#41;&#40;0x40020000 &#43; 0x14&#41;</code></p> </ul> <li><p>Make it volatile, to tell compiler that its value might change by hardware, so don&#39;t optimize. </p> <ul> <li><p><code>#define GPIOAODR &#40;volatile int *&#41;&#40;0x40020000 &#43; 0x14&#41;</code></p> </ul> <li><p>Then dereference it using *, to act on the value stored <strong>IN</strong> the address</p> <ul> <li><p><code>#define GPIOAODR &#40;*&#40;volatile int *&#41;&#40;0x40020000 &#43; 0x14&#41;&#41;</code></p> </ul> </ol> <h2 id=blinky_example_on_stm32nucleo_with_stm32f401xe_definitions ><a href="#blinky_example_on_stm32nucleo_with_stm32f401xe_definitions" class=header-anchor >Blinky Example on STM32Nucleo with stm32f401xe definitions</a></h2> <p>Supplied with the microcontroller is a header that has macro definitions for all the different registers and bitmasks for our specific microcontroller. This header doesn&#39;t add functions but only handy macros in order not to have to read the reference and manually find what the address location is, but instead, just use the macro definitions. Use expressive words instead of numbers. </p> <p>The exact same code as before, but we use the provided macro definitions for the addresses, address shifts and bitmasks &#40;exactly similar binary as before&#41;. Note that we use the <code>stm32f401xe.h</code> header file.</p> <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;stm32f401xe.h&quot;</span></span>

<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >void</span>)</span> </span>{
    <span class=hljs-comment >/* Enable GPIOA Clock */</span>
    RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN; <span class=hljs-comment >/* Ref RCC_AHB2ENR register */</span>
    <span class=hljs-comment >/* Set Port A Pin 5 as Output */</span>
    GPIOA-&gt;MODER |= (<span class=hljs-number >1</span> &lt;&lt; GPIO_MODER_MODE0_Pos); <span class=hljs-comment >/* Ref GPIOx_MODER register */</span>
    <span class=hljs-keyword >while</span> (<span class=hljs-number >1</span>) {
        <span class=hljs-comment >/* Set LED Pin High */</span>
        GPIOA-&gt;ODR |= (<span class=hljs-number >1</span> &lt;&lt; GPIO_ODR_OD5_Pos); <span class=hljs-comment >/* Ref GPIOx_ODR register*/</span>
        <span class=hljs-comment >/* Dumb Delay: wait x number of clock cycles */</span>
        <span class=hljs-keyword >for</span> (<span class=hljs-keyword >int</span> k = <span class=hljs-number >0</span>; k&lt;<span class=hljs-number >1000000</span>; k++){__asm(<span class=hljs-string >&quot;nop&quot;</span>);}
        <span class=hljs-comment >/* Set LED Pin Low */</span>
        GPIOA-&gt;ODR &amp;= ~(<span class=hljs-number >1</span> &lt;&lt; GPIO_ODR_OD5_Pos); <span class=hljs-comment >/* Ref GPIOx_ODR register*/</span>
        <span class=hljs-comment >/* Dumb Delay */</span>
        <span class=hljs-keyword >for</span> (<span class=hljs-keyword >int</span> k = <span class=hljs-number >0</span>; k&lt;<span class=hljs-number >1000000</span>; k++){__asm(<span class=hljs-string >&quot;nop&quot;</span>);}
    }
}</code></pre> <blockquote> <p>Still Low-Level C but with the help of macro definitions &#40;at no extra memory overhead charge&#41;</p> </blockquote> <h3 id=blinky_example_on_stm32nucleo_with_stm32cube_hal ><a href="#blinky_example_on_stm32nucleo_with_stm32cube_hal" class=header-anchor >Blinky Example on STM32Nucleo with STM32Cube HAL</a></h3> <p>ST provides an abstraction for their MCUs called STM32Cube, this is a blinky routine using their abstraction. Program Size: 404 Bytes</p> <p>The STM32Cube is a C library that has many functions defined for setting and interacting with the MCU. </p> <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;stm32f4xx_hal.h&quot;</span> <span class=hljs-comment >/* We don&#x27;t include the specific stm32f401xe header, but just the HAL */</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;stm32f4xx.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >define</span> LED_GPIO_CLK_ENABLE()                  __HAL_RCC_GPIOA_CLK_ENABLE()</span>

<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >void</span>)</span></span>{
  <span class=hljs-built_in >HAL_Init</span>(); <span class=hljs-comment >/* Initialize the HAL Drivers */</span>
  
  <span class=hljs-built_in >LED_GPIO_CLK_ENABLE</span>(); <span class=hljs-comment >/* Enable GPIO A Clock */</span>
  GPIO_InitTypeDef GPIO_InitStruct; 
  GPIO_InitStruct.Pin = GPIO_PIN_5;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  <span class=hljs-built_in >HAL_GPIO_Init</span>(GPIOA, &amp;GPIO_InitStruct); <span class=hljs-comment >/* The pin configuration is done through a function */</span>

  <span class=hljs-keyword >while</span> (<span class=hljs-number >1</span>)
  {
    <span class=hljs-built_in >HAL_GPIO_TogglePin</span>(GPIOA, GPIO_PIN_5); <span class=hljs-comment >/* HAL provides a toggle pin function */</span>
    <span class=hljs-built_in >HAL_Delay</span>(<span class=hljs-number >1000</span>); <span class=hljs-comment >/* As well as a delay function (milliseconds) */</span>
  }
}</code></pre> <blockquote> <p>Higher Lower Level C Code, this is the recommended level for commercial/professional programming of MCU. Portable across other STM32 MCUs</p> </blockquote> <h3 id=blinky_example_on_stm32nucleo_with_arduino ><a href="#blinky_example_on_stm32nucleo_with_arduino" class=header-anchor >Blinky Example on STM32Nucleo with Arduino</a></h3> <p>And this is the blinky code using the Arduino framework</p> <p>Program Size: 12404 Bytes. Abstraction comes at a cost&#33;</p> <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;Arduino.h&gt;</span></span>

<span class=hljs-function ><span class=hljs-keyword >void</span> <span class=hljs-title >setup</span><span class=hljs-params >()</span> </span>{ <span class=hljs-built_in >pinMode</span>(LED_BUILTIN, OUTPUT); }

<span class=hljs-function ><span class=hljs-keyword >void</span> <span class=hljs-title >loop</span><span class=hljs-params >()</span> </span>{
    <span class=hljs-built_in >digitalWrite</span>(LED_BUILTIN, HIGH);
    <span class=hljs-built_in >delay</span>(<span class=hljs-number >50</span>);
    <span class=hljs-built_in >digitalWrite</span>(LED_BUILTIN, LOW);
    <span class=hljs-built_in >delay</span>(<span class=hljs-number >200</span>);
}</code></pre> <blockquote> <p>A good level of abstraction. Good for education / hobbyist / prototyping / quick lab instruments. Portable across all MCUs that have an Arduino adoption</p> </blockquote> <h2 id=other_available_frameworks ><a href="#other_available_frameworks" class=header-anchor >Other available frameworks</a></h2> <ul> <li><p>CMSIS: Cortex Microcontroller Software Interface Standard</p> <ul> <li><p>Developed by ARM</p> <li><p>Universal across other ARM Cortex MCU, not just ST</p> </ul> <li><p>SPL: Standard Peripheral Library</p> <ul> <li><p>Developed by ST for ST based ARM MCUs</p> </ul> <li><p>HAL ST: Hardware Abstraction Layer ST</p> <ul> <li><p>Developed by ST for ST based ARM MCUs, with focus on abstraction</p> </ul> <li><p>Arduino</p> <ul> <li><p>Developed for hobbyists and prototypists</p> <li><p>Become so popular, that manufacturers provide support for it </p> </ul> </ul> <h2 id=standard_peripheral_library_stm32cube ><a href="#standard_peripheral_library_stm32cube" class=header-anchor >Standard Peripheral Library / STM32Cube</a></h2> <p>Modern microcontrollers pack a lot of features and peripherals. Configuring peripherals through direct register access becomes cumbersome for a programmer. Using manufacturers provided standard libraries “framework” is becoming standard practice. Libraries abstract away differences between microcontrollers so code can be more portable. If you run out of stock on an STM32F4x board, you can move to an STM32F7 board much faster with the HAL than if you used the standard peripheral library or even harder if you only used the board defintions header file. </p> <p>HAL: Hardware Abstraction Layer Libraries are practically more proof tested with fewer bugs</p> <h2 id=how_to_know_what_to_do_and_where_to_find_information ><a href="#how_to_know_what_to_do_and_where_to_find_information" class=header-anchor >How to know what to do and where to find information?</a></h2> <p>Configuring and programming an MCU is not a straight-forward or linear process. It comes with experience, but it&#39;s a rewarding experience. There are multiple references and tools that must be used concurrently With STM32Nucleo for example, we use:</p> <ul> <li><p><a href="/me319/assets/reference_docs/REF01_STM32F401RE_DATASHEET.pdf">Datasheet</a>, which gives the &quot;specs&quot;</p> <li><p><a href="/me319/assets/reference_docs/REF02_STM32F401xBC_and_STM32F401xDE_Reference_Manual_Table38_Vector_Table.pdf">Reference Manual</a> , A guide on how to configure and use the MCU</p> <ul> <li><p>Registers Information</p> <li><p>Possible Configurations</p> <li><p>Used by developers</p> </ul> <li><p><a href="/me319/assets/reference_docs/REF03_STM32_Nucleo-64_boards_User_Manual.pdf">User Manual for STM32 Nucleo</a></p> <li><p>Framework User Manual &#40;e.g. <a href="/me319/assets/reference_docs/REF05_Description_of_STM32F4_HAL_and_LL_drivers.pdf">HAL and LL User Manual</a>&#41;</p> <li><p>Example Code for framework selected</p> <li><p>Consult developer community</p> </ul> <p>Next: <a href="../lecture6/">Part I L6 - Timers</a> </p> <div class=page-foot > <div class=copyright > &copy; Ali AlSaibie, PhD. Last modified: May 29, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div>