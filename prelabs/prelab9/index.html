<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/me319/libs/highlight/github.min.css"> <link rel=stylesheet  href="/me319/css/franklin.css"> <link rel=stylesheet  href="/me319/css/poole_hyde.css"> <link rel=stylesheet  href="/me319/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 968px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/me319/assets/c.svg"> <title>Prelab 9 Realtime Motor Control</title> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <img src="/me319/assets/KuwaitUniversityLogoTextLight.svg" style="width: 200px; height: auto; display: inline"> <h1 style="font-size:2em; opacity: 0.75;"><a href="/me319/">ME 319</a></h1> <p class=lead >Mechatronics</p> </div> <script> function hidePart(part_div) { var x = document.getElementById(part_div); if (x.style.display === "none") { x.style.display = "block"; } else { x.style.display = "none"; } } </script> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/me319/">Home</a> <a class="sidebar-nav-item " href="/me319/videos/">Lecture Videos</a> <a class="sidebar-nav-item " href="https://alsaibie.github.io/embedded_ccpp">Embedded C/C++ Mini-Course</a> <a class="sidebar-nav-item " href="/me319/lab_assignments/">Lab Assignments</a> <br> <small style="text-transform: uppercase; font-size: 0.75em">Lab Lessons</small> <div class=part  onclick="hidePart('prelabs_div')">Prelabs</div> <div id=prelabs_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/prelabs/prelab2/"><b>Lab 2</b> - <em>PlatformIO and Arduino</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab3/"><b>Lab 3</b> - <em>Debugging and LL Programming</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab4/"><b>Lab 4</b> - <em>Timers and Interrupts</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab5/"><b>Lab 5</b> - <em>Serial Communication</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab6/"><b>Lab 6</b> - <em>Offline Digital Filtering</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab7/"><b>Lab 7</b> - <em>Online Digital Filtering</em></a> <a class="sidebar-nav-item " href="/me319/prelabs/prelab8/"><b>Lab 8</b> - <em>Motor Dynamics and Control</em></a> <a class="sidebar-nav-item active" href="/me319/prelabs/prelab9/"><b>Lab 9</b> - <em>Realtime Motor Control</em></a> </div> <div class=part  onclick="hidePart('addlessons_div')">Additional Lessons</div> <div id=addlessons_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/prelabsextra/lab4extra/"> <b>L4E</b> - <em>Low Level Timers Configuration</em></a> <a class="sidebar-nav-item " href="/me319/prelabsextra/kalmanfilter/"> <b>L6E</b> - <em>Kalman Filter</em></a> </div> <br> <small style="text-transform: uppercase; font-size: 0.75em">Class Lectures</small> <div class=part  onclick="hidePart('part1_div')">I The Brain</div> <div id=part1_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_i/lecture0/"><b>L0</b> - <em>Introduction</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture1/"><b>L1</b> - <em>Microcontroller Architecture</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture2/"><b>L2</b> - <em>Digital Arithmetic</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture3/"><b>L3</b> - <em>Digital Logic</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture4/"><b>L4</b> - <em>Microcontroller Peripherals</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture5/"><b>L5</b> - <em>GPIO</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture6/"><b>L6</b> - <em>Timers</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture7/"><b>L7</b> - <em>Interrupts</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture8/"><b>L8</b> - <em>Communication</em></a> </div> <div class=part  onclick="hidePart('part2_div')">II The Cells</div> <div id=part2_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_ii/lecture1/"><b>L1</b> - <em>Passive Circuits</em></a> <a class="sidebar-nav-item " href="/me319/part_ii/lecture2/"><b>L2</b> - <em>Switching Semiconductors</em></a> <a class="sidebar-nav-item " href="/me319/part_ii/lecture3/"><b>L3</b> - <em>Operational Amplifiers</em></a> </div> <div class=part  onclick="hidePart('part3_div')">III The Senses</div> <div id=part3_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_iii/lecture1/"><b>L1</b> - <em>Signal Conditioning and Filtering</em></a> <a class="sidebar-nav-item " href="/me319/part_iii/lecture2/"><b>L2</b> - <em>Sensor Charactersitics</em></a> <a class="sidebar-nav-item " href="/me319/part_iii/lecture3/"><b>L3</b> - <em>Survey of Sensors</em></a> <a class="sidebar-nav-item " href="/me319/part_iii/lecture4/"><b>L4</b> - <em>Motion Sensors</em></a> </div> <div class=part  onclick="hidePart('part4_div')">IV The Muscles</div> <div id=part4_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_iv/lecture1/"><b>L1</b> - <em>DC Motors</em></a> <a class="sidebar-nav-item " href="/me319/part_iv/lecture2/"><b>L2</b> - <em>Practical Feedback Control</em></a> <a class="sidebar-nav-item " href="/me319/part_iv/lecture4/"><b>L3</b> - <em>Stepper Motors</em></a> </div> <div class=part  onclick="hidePart('part5_div')">V The Body</div> <div id=part5_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_v/lecture1/"><b>L1</b> - <em>System Integration</em></a> </div> </nav> <p>&copy; Ali AlSaibie, PhD.</p> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=prelab_9_realtime_motor_control ><a href="#prelab_9_realtime_motor_control" class=header-anchor >Prelab 9: Realtime Motor Control</a></h1> <p>In this lab we will learn how to implement a feedback controller, in order to perform both speed and position control on a conventional brushed DC motor. We will apply what we learned about timers in <a href="/me319/prelabs/prelab4/">Lab 4</a> to implement a feedback control structure.</p> <h2 id=tools_required ><a href="#tools_required" class=header-anchor >Tools Required </a></h2> <ol> <li><p>STM32 Nucleo F401RE Board </p> <li><p>USB Type A to USB Mini-B Connector</p> <li><p>X-Nucleo-IKS01A2</p> <li><p>X-Nucleo-IHM04A1 </p> </ol> <p><a href="/me319/prelabs/pl9assets/ME319S21Prelab9.zip">Project Template</a></p> <h2 id=references ><a href="#references" class=header-anchor >References</a></h2> <ol> <li><p><a href="/me319/assets/reference_docs/REFC1_XNUCLEO_IHM04A1_Quick_Start_Guide.pdf">REFC1 XNUCLEO IHM04A1 Quick Start Guide</a></p> <li><p><a href="/me319/assets/reference_docs/REFC2_XNUCLEO_IHM04A1_mbed_pinout_v1.jpg">REFC2 XNUCLEO IHM04A1 mbed pinout v1</a></p> <li><p><a href="/me319/assets/reference_docs/REF03_STM32_Nucleo-64_boards_User_Manual.pdf">REFC3 XNUCLEO IHM04A1 Databrief</a></p> <li><p><a href="/me319/assets/reference_docs/REFC4_L6206_DMOS_DUAL_FULLBRIDGE_DRIVER.pdf">REFC4 L6206 DMOS DUAL FULLBRIDGE DRIVER</a></p> <li><p><a href="/me319/assets/reference_docs/REFC5_MAGNETIC_ENCODER.pdf">REFC5 MAGNETIC ENCODER</a></p> <li><p><a href="/me319/assets/reference_docs/REFC6A_Motor_Specifications_290-006_ig220019x00015r_ds.pdf">REFC6A Motor Specifications 290-006&#95;ig220019x00015r&#95;ds</a></p> <li><p><a href="/me319/assets/reference_docs/REFC6B_Motor_Specifications_290-008_ig220053x00085r_ds.pdf">REFC6B Motor Specifications_290-008&#95;ig220053x00085r&#95;ds</a></p> <li><p>Lab Report Submission Guidelines</p> </ol> <center><img src="/me319/prelabs/pl9assets/motor.gif" style="max-width:420px"></center> <h2 id=conventional_dc_motor ><a href="#conventional_dc_motor" class=header-anchor >Conventional DC Motor</a></h2> <p>A DC motor is a commonly used actuator in numerous systems. A brushed DC motor, which we will be using in this lab, consists of a housing, bearings on which the output shaft is supported, stator &#40;non-rotating part&#41; that encompass the magnets and then the rotor which combines the drive shaft, the coils that current flows through and generate an Electromagnetic Force, the commutator that sends the current to the armature and brushes that force current through the coils.</p> <h2 id=motor_driver ><a href="#motor_driver" class=header-anchor >Motor Driver</a></h2> <p>A common and universally used brushed DC motor driving circuit is known as an H-Bridge circuit. The circuit allows for routing the current from the power supply through the motor by way of operating four switching semiconductors resembling the letter H. A motor driver normally encompasses the H-Bridge circuit along with power and driving logic. As shown on the following figure.</p> <center><img src="/me319/prelabs/pl9assets/motordriver.png" style="max-width:780px"></center> <p>In the figure, OUT1 and OUT2 are connected to the motor terminals. IN1 and IN2 are inputs from the microcontroller. The A and B denote two Full H-Bridge drivers on the chip, capable of driving two bidirectional brushed DC motors. The transistors used in the H-Bridge circuit are N-Channel Power MOSFETs &#40;NFETs&#41;. EN is a driver enable input, this pin must be set to HIGH in order to enable output to the motors.</p> <p>The gate logic of the motor driver chip switches the NFET pairs according to the inputs IN1 and IN2. If IN1 is high and IN2 is low, OUT1 is connected to Vs and OUT2 is connected to GND. Vs is the motor supply voltage. If IN1 is driven by a PWM signal, the motor will be supplied with a voltage matching the frequency and duty cycle of the PWM signal. L6206 H-Bridge Truth Table shows the logic of the output pins based on the inputs. </p> <p>To switch the direction of the motor, then IN1 is set low and IN2 is driven by the PWM signal instead. </p> <center><img src="/me319/prelabs/pl9assets/truthtable.png" style="max-width:780px"></center> <h2 id=quadrature_encoder ><a href="#quadrature_encoder" class=header-anchor >Quadrature Encoder</a></h2> <p>Also known as an optical sensor, an opto-interrupter is composed of an emitter, detector and a rotating disk with slots that allow light to go through. As the disk rotates, the light is blocked and unblocked from the detector as the slots come in and leave from in-between the emitter and detector. The disk can be attached to a motor shaft and by observing the opto-interrupter signal, the speed of the motor can be measured. This setup is also referred to as a motor encoder.</p> <p>The rotary disks can have more than one slot, the more slots there are the higher the resolution in measuring speed and position. A quadrature encoder is one where the rotating part is composed of two offset slotted disks. The offset is normally 90o, this is also known as the phase lag. </p> <p>Each disk is considered a channel, and when the motor is rotating in one direction, one channel will lead the other by a quarter of a period and vice versa for the other direction. A quadrature encoder can be used not only to measure speed and position of the motor but also the direction of rotation, Figure Quadrature Encoder. </p> <center><img src="/me319/prelabs/pl9assets/QuadratureEncoder.svg" style="max-width:780px"></center><br> <p>In this lab, we will be using a quadrature encoder to measure the position, speed and direction of the motor. </p> <h2 id=timers ><a href="#timers" class=header-anchor >Timers</a></h2> <p>Timers are essential in achieving the required structure for real-time control. We know that we can use a timer to generate periodic function calls, or to generate a PWM signal or to read the pulse counts or frequency of an input signal. </p> <p>The following list of timers and interrupts will be used:</p> <ol> <li><p>PWM Timer: This timer will be used to generate a PWM signal on two outputs connected to the motor driver.</p> <li><p>Periodic Timer: This timer will be called at a fixed rate to compute the next control action, executing the PID control law. </p> <li><p>Input Capture Timer: This timer will be connected to the encoder channels A and B signals and will be used to keep count of the number of pulses and the frequency of the pulses, in order to measure the position and velocity of the motor respectively. </p> </ol> <p>The timers are configured in a similar fashion as done in Prelab 4. </p> <h2 id=electrical_connections ><a href="#electrical_connections" class=header-anchor >Electrical Connections</a></h2> <p>For this lab we will be using the X-Nucleo-IHM04A1 Expansion board, which hosts the L6206 motor driver IC. The board stacks on top of the Nucleo F401RE microcontroller board using the Arduino connection headers. Connect the motor terminals &#40;red and black wire&#41; to Bridge A &#40;A&#43; and A-&#41; of the board, polarity doesn’t matter, as the motor will just spin in the opposite direction. Connect the 12V power supply to the Input of the IHM04A1 expansion board, but polarity matters here obviously. The expansion board already connects IN1A and IN2A to pins PB<em>4 and PB</em>5 of the microcontroller, respectively. To connect the encoder, connect the blue wire &#40;ENC Channel A&#41; to pin PA<em>B and purple wire &#40;ENC Channel B&#41; to pin PA</em>9. Connect the green wire to GND and the brown to &#43;5V. </p> <center><img src="/me319/prelabs/pl9assets/IHM04A1pinout.jpg" style="max-width:680px"></center><br> <p>The L6206 IC also offers motor current sensing, and the expansion board connects Bridge A’s current sensing output to pin PA&#95;6.</p> <center><img src="/me319/prelabs/pl9assets/MotorDriverShieldWiring.jpg" style="max-width:680px"></center><br> <h2 id=feedback_control ><a href="#feedback_control" class=header-anchor >Feedback Control</a></h2> <p>A cascaded controller will be used to control the position of the motor, the inner loop is a PID speed feedback controller, also known as a rate controller, the outer loop is a proportional position controller. As shown on Figure 8 Cascaded Position and Speed Control Block Diagram </p> <center><img src="/me319/prelabs/pl9assets/bdiagram.png" style="max-width:780px"></center><br> <h2 id=motor_command ><a href="#motor_command" class=header-anchor >Motor Command</a></h2> <p>The outputs of the microcontroller to control the motor are two PWM signals, in addition to the enable signal. As explained in Section ‎5, one of the PWM pins should be set to LOW &#40;0&#37; duty cycle&#41;, and the other one given a PWM signal with a duty cycle proportional to the supply voltage desired. To rotate the motor in the opposite direction, the latter output is set LOW while the former is given the required duty cycle. </p> <div class=page-foot > <div class=copyright > &copy; Ali AlSaibie, PhD. Last modified: June 26, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div>