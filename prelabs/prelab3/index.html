<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/me319/libs/highlight/github.min.css"> <link rel=stylesheet  href="/me319/css/franklin.css"> <link rel=stylesheet  href="/me319/css/poole_hyde.css"> <link rel=stylesheet  href="/me319/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 968px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/me319/assets/c.svg"> <title>Prelab 2 - Getting familiar with PlatformIO and Arduino</title> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <img src="/me319/assets/KuwaitUniversityLogoTextLight.svg" style="width: 200px; height: auto; display: inline"> <h1 style="font-size:2em; opacity: 0.75;"><a href="/me319/">ME 319</a></h1> <p class=lead >Mechatronics</p> </div> <script> function hidePart(part_div) { var x = document.getElementById(part_div); if (x.style.display === "none") { x.style.display = "block"; } else { x.style.display = "none"; } } </script> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/me319/">Home</a> <a class="sidebar-nav-item " href="/me319/videos/">Lecture Videos</a> <a class="sidebar-nav-item " href="https://alsaibie.github.io/embeddedcpp_course">Embedded C/C++ Mini-Course</a> <a class="sidebar-nav-item " href="/me319/lab_assignments/">Lab Assignments</a> <br> <small style="text-transform: uppercase; font-size: 0.75em">Class Lectures</small> <div class=part  onclick="hidePart('part1_div')">I The Brain</div> <div id=part1_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_i/lecture0/"><b>L0</b> - <em>Introduction</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture1/"><b>L1</b> - <em>Microcontroller Architecture</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture2/"><b>L2</b> - <em>Digital Arithmetic</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture3/"><b>L3</b> - <em>Digital Logic</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture4/"><b>L4</b> - <em>Microcontroller Peripherals</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture5/"><b>L5</b> - <em>GPIO</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture6/"><b>L6</b> - <em>Timers</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture7/"><b>L7</b> - <em>Interrupts</em></a> <a class="sidebar-nav-item " href="/me319/part_i/lecture8/"><b>L8</b> - <em>Communication</em></a> </div> <div class=part  onclick="hidePart('part2_div')">II The Cells</div> <div id=part2_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_ii/lecture1/"><b>L1</b> - <em>Passive Circuits</em></a> <a class="sidebar-nav-item " href="/me319/part_ii/lecture2/"><b>L2</b> - <em>Switching Semiconductors</em></a> <a class="sidebar-nav-item " href="/me319/part_ii/lecture3/"><b>L3</b> - <em>Operational Amplifiers</em></a> </div> <div class=part  onclick="hidePart('part3_div')">III The Senses</div> <div id=part3_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_iii/lecture1/"><b>L1</b> - <em>Signal Conditioning and Filtering</em></a> <a class="sidebar-nav-item " href="/me319/part_iii/lecture2/"><b>L2</b> - <em>Sensor Charactersitics</em></a> <a class="sidebar-nav-item " href="/me319/part_iii/lecture3/"><b>L3</b> - <em>Survey of Sensors</em></a> <a class="sidebar-nav-item " href="/me319/part_iii/lecture4/"><b>L4</b> - <em>Motion Sensors</em></a> </div> <div class=part  onclick="hidePart('part4_div')">IV The Muscles</div> <div id=part4_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_iv/lecture1/"><b>L1</b> - <em>DC Motors</em></a> <a class="sidebar-nav-item " href="/me319/part_iv/lecture2/"><b>L2</b> - <em>Practical Feedback Control</em></a> <a class="sidebar-nav-item " href="/me319/part_iv/lecture4/"><b>L3</b> - <em>Stepper Motors</em></a> </div> <div class=part  onclick="hidePart('part5_div')">V The Body</div> <div id=part5_div  style="display:none;"> <a class="sidebar-nav-item " href="/me319/part_v/lecture1/"><b>L1</b> - <em>System Integration</em></a> </div> </nav> <p>&copy; Ali AlSaibie, PhD.</p> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=prelab_3_introduction_to_mcu_debugging_and_low-level_programming ><a href="#prelab_3_introduction_to_mcu_debugging_and_low-level_programming" class=header-anchor >Prelab 3: Introduction to MCU Debugging and Low-Level Programming</a></h1> <p>In this prelab we will exercise basic debugging on the microcontroller, then we will experiment with programming the microcontroller GPIO on a low-level without any added headers. Debugging features are applicable whether we choose to program the microcontroller on a low-level, or higher abstraction level. The debugging features are independent of the framework used.</p> <p>First let&#39;s create a new PlatformIO project, but this time, let&#39;s select the <strong>STM32Cube</strong> framework. Which is a collection of headers including functions and macros provided by ST for their line of STM32 microcontrollers.</p> <p>Create a new project. Name it Prelab3, select the ST Nucleo F401RE board and the <strong>STM32Cube</strong> framework.</p> <p>Add the <code>src_filter</code> instruction in the platform.ini file as shown. Note that we will technically be programming in <strong>C</strong>, not <strong>C&#43;&#43;</strong>. Hence the &#42;.c extension</p> <pre><code class="julia hljs">[env:nucleo_f401re]
platform = ststm32
board = nucleo_f401re
framework = stm32cube
src_filter = -&lt;main*.c&gt; +&lt;mainE1.c&gt;</code></pre> <p>You will notice that no source files exist under <code>src</code>. Place the source files supplied with this prelab assignment into the <code>src</code> folder. You can find them <a href="/me319/prelabs/pl3assets/ME319_PRELAB_3_Code_Spring2021.zip">here</a>. </p> <p>Alternatively, you can create a new source file by right clicking on src folder -\&gt; New File and naming it with &#42;.c extension.</p> <h2 id=debugging_on_an_mcu_via_platformio ><a href="#debugging_on_an_mcu_via_platformio" class=header-anchor >Debugging on an MCU via PlatformIO</a></h2> <p>Let&#39;s familiarize ourselves with the debugging process now. Debugging allows you to step through the code one line at a time or down to one assembly instruction at a time. </p> <p>This helps you to troubleshoot your code and keep track of your algorithm at the step level you choose. This is a powerful feature when developing programs, as well as a way to gain more experience and knowledge in programming and program behavior.</p> <p>With your project created, source files added, and <code>src_filter</code> set in the platform.ini file for <code>mainE1.c</code>. Go ahead and click on the Bug symbol on the left task pane</p> <p> <center><img src="/me319/prelabs/pl3assets/image1.png" style="max-width:420px"></center> </p> <p>Then on the top left, open the DEBUG AND RUN drop down menu and select the <strong>PIO Debug</strong> &#40;<em>you&#95;project&#95;name</em>&#41; debug configuration, then hit the <strong>green</strong> play button.</p> <p> <center><img src="/me319/prelabs/pl3assets/image2.png" style="max-width:420px"></center> </p> <p>The code will compile <code>mainE1.c</code> in debug mode, flash it into the microcontroller and once loaded and started, it will pause the program inside the <code>main&#40;&#41;</code> function. Note that when you upload regularly without debugging, the MCU boots and runs the program normally without pausing.</p> <p>Now you are ready to debug and step through the code.</p> <p>Explore the different parts of the debugging workspace. On the left, you see a tab for variables, one for peripheral registers, one for watch variables, etc. On the top right corner there is the debugging step control, where you can resume the program, pause, stop, step through the code, step in and step out of functions, and restart.</p> <p>Carryout the following steps to explore the debugger</p> <ul> <li><p>Go to the debugger step control pane and hit the <strong>step over</strong> button &#40;F10&#41;, the program will execute one line inside main&#40;&#41; and pause, press <strong>step over</strong> several times and observe what happens to the variables under the variables watch.</p> <li><p>Go to the watch tab and add an expression &#40;&#43; button&#41;, type <code>g_a*3</code> as the new expression, you will notice that the watch output will be <code>3*g_a</code>. You can use the watch tab to keep track of variables and expressions, and as you just did, make up your own expressions.</p> <li><p>Note that under the peripherals tab, you can see the values inside all the peripheral registers grouped by bitfields as they are laid out in the reference manual.</p> <li><p>When you reach the <code>increment&#40;&amp;c&#41;</code> function line, as you step over, click on the <strong>step into</strong> button &#40;F11&#41;, this will take you inside the function call instance. To jump out of the function click on the <strong>step out</strong> button &#40;Shift&#43;F11&#41;.</p> <li><p>Note that step over does not take you inside the functions. You have to specifically <strong>step in</strong> functions. Or you can setup a breakpoint inside the function.</p> </ul> <p>Let&#39;s explore the use of breakpoints now.</p> <p>To the left of the line numbers in the editor, go to line 12 and to the left of it <strong>click once</strong> in the empty white space, a red dot will appear. This read dot is a breakpoint. This will let the debugger stop the program once it&#39;s reached. Click on Continue &#40;F5&#41;, your program will continue executing until a breakpoint is reached. If you did not have a breakpoint and you click continue &#40;F5&#41;, your program will continue executing until it terminates.</p> <p>Click Restart &#40;CTRL&#43;Shift&#43;F5&#41; to restart the program, then carryout the following step to explore the use of breakpoints </p> <ul> <li><p>Add a breakpoint at line 13, then right click on the breakpoint and select edit breakpoint, then type the expression <code>c &#61;&#61; 2</code>, as shown and hit enter. Then press continue &#40;F5&#41;</p> </ul> <p> <center><img src="/me319/prelabs/pl3assets/image3.png" style="max-width:420px"></center> </p> <p>You will notice that the program continues and stops when the variable <code>c</code> becomes equal to 2. You can also choose to have the breakpoint activate when a specific line has been hit a number of times, by choosing Hit Count instead of Expression.</p> <h2 id=low-level_blinky_code ><a href="#low-level_blinky_code" class=header-anchor >Low-Level Blinky Code</a></h2> <p>The following part assumes you have reviewed <a href="/me319/part_i/lecture5/">Part I Lecture 5 GPIO</a></p> <p>In class, we reviewed the different ways we can program a <strong>blinky</strong> routine on the STM32Nucleo. Let&#39;s test the low-level example &#40;without headers&#41; and use the debugger to explore what happens to the values in the respective registers. Go to the platform.ini file and change <code>mainE1.c</code> to <code>mainE2.c</code> in the src_filter. In order to compile example 2 instead.</p> <code>mainE2.c</code> <pre><code class="cpp hljs"><span class=hljs-comment >/* Look Ma!, no headers */</span>

<span class=hljs-comment >/***
 * Blinky Program - LED connected to PA5
 * */</span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >define</span> GPIOARCCR (*(volatile int *)(0x40023800 + 0x30))</span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >define</span> GPIOAMODER (*(volatile int *)0x40020000)</span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >define</span> GPIOAODR (*(volatile int *)(0x40020000 + 0x14))</span>

<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >void</span>)</span> </span>{
    <span class=hljs-comment >/* Step 1: Enable GPIOA Clock */</span>
    GPIOARCCR |= <span class=hljs-number >1</span>; <span class=hljs-comment >/* Ref RCC_AHB2ENR register */</span>
    <span class=hljs-comment >/* Step 2: Set Port A Pin 5 as Output */</span> 
    GPIOAMODER |= (<span class=hljs-number >1</span> &lt;&lt; <span class=hljs-number >10</span>); <span class=hljs-comment >/* Ref GPIOx_MODER register */</span>
    <span class=hljs-keyword >while</span> (<span class=hljs-number >1</span>) {
        <span class=hljs-comment >/* Step 3a: Set LED Pin High */</span>
        GPIOAODR |= (<span class=hljs-number >1</span> &lt;&lt; <span class=hljs-number >5</span>); <span class=hljs-comment >/* Ref GPIOx_ODR register*/</span>
        <span class=hljs-comment >/* Dumb Delay: wait x number of clock cycles */</span>
        <span class=hljs-keyword >for</span> (<span class=hljs-keyword >int</span> k = <span class=hljs-number >0</span>; k&lt;<span class=hljs-number >500000</span>; k++){__asm(<span class=hljs-string >&quot;nop&quot;</span>);}
        <span class=hljs-comment >/* Step 3b: Set LED Pin Low */</span>
        GPIOAODR &amp;= ~(<span class=hljs-number >1</span> &lt;&lt; <span class=hljs-number >5</span>); <span class=hljs-comment >/* Ref GPIOx_ODR register*/</span>
        <span class=hljs-comment >/* Dumb Delay */</span>
        <span class=hljs-keyword >for</span> (<span class=hljs-keyword >int</span> k = <span class=hljs-number >0</span>; k&lt;<span class=hljs-number >500000</span>; k++){__asm(<span class=hljs-string >&quot;nop&quot;</span>);}
    }
}</code></pre> <p>Upload the code through the <strong>debug</strong> mode presented above, then step through the lines and observe the changes that occur in the respective registers under the <strong>peripherals</strong> pane. Specifically,</p> <ul> <li><p>At step one, we enable the GPIO A clock. To do that, we change the RCC&#95;AHB1ENR register&#39;s GPIOAEN bitfield. Which is bit 0 of the RCC&#95;AHB1ENR register. &#40;You can find it under RCC Peripheral, or type the name in your keyboard and it will filter the results for you&#41;</p> </ul> <p> <center><img src="/me319/prelabs/pl3assets/image4.png" style="max-width:420px"></center> </p> <ul> <li><p>At step two, we set GPIO Port A Pin 5 &#40;PA5&#41; to output. For this we manipulate the GPIOA&#95;MODER, Mode Register, bits &#91;11:10&#93;</p> <li><p>At step 3a &#40;3b&#41; we set the GPIOA_ODR, Output Data Register, bit 5 to high &#40;low&#41;</p> </ul> <p> <center><img src="/me319/prelabs/pl3assets/image5.png" style="max-width:420px"></center> <center><img src="/me319/prelabs/pl3assets/image6.png" style="max-width:420px"></center> </p> <p>Congratulations, you&#39;ve debugged your first MCU program and executed a low-level <strong>blinky</strong> routine.</p> <p>Go ahead and test running <code>mainE3.c</code>, it is equivalent to <code>mainE2.c</code>, but uses the macro definitions for the register addresses and bitmasks from the header &quot;stm32f401xe.h&quot;, which is supplied by the board manufacturer, ST, through the PlatformIO IDE. </p> <code>mainE3.c</code> <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;stm32f401xe.h&quot;</span></span>

<span class=hljs-comment >/***
 * Blinky Program - LED connected to PA5
 * */</span>

<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >void</span>)</span> </span>{
    <span class=hljs-comment >/* Enable GPIOA Clock */</span>
    RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN; <span class=hljs-comment >/* Ref RCC_AHB2ENR register */</span>
    <span class=hljs-comment >/* Set Port A Pin 5 as Output */</span>
    GPIOA-&gt;MODER |= (<span class=hljs-number >1</span> &lt;&lt; GPIO_MODER_MODE5_Pos); <span class=hljs-comment >/* Ref GPIOx_MODER register */</span>
    <span class=hljs-keyword >while</span> (<span class=hljs-number >1</span>) {
        <span class=hljs-comment >/* Set LED Pin High */</span>
        GPIOA-&gt;ODR |= (<span class=hljs-number >1</span> &lt;&lt; GPIO_ODR_OD5_Pos); <span class=hljs-comment >/* Ref GPIOx_ODR register*/</span>
        <span class=hljs-comment >/* Dumb Delay: wait x number of clock cycles */</span>
        <span class=hljs-keyword >for</span> (<span class=hljs-keyword >int</span> k = <span class=hljs-number >0</span>; k&lt;<span class=hljs-number >1000000</span>; k++){__asm(<span class=hljs-string >&quot;nop&quot;</span>);}
        <span class=hljs-comment >/* Set LED Pin Low */</span>
        GPIOA-&gt;ODR &amp;= ~(<span class=hljs-number >1</span> &lt;&lt; GPIO_ODR_OD5_Pos); <span class=hljs-comment >/* Ref GPIOx_ODR register*/</span>
        <span class=hljs-comment >/* Dumb Delay */</span>
        <span class=hljs-keyword >for</span> (<span class=hljs-keyword >int</span> k = <span class=hljs-number >0</span>; k&lt;<span class=hljs-number >1000000</span>; k++){__asm(<span class=hljs-string >&quot;nop&quot;</span>);}
    }
}</code></pre> <p>So instead of referencing the registers addresses manually, the &quot;stm32f401xe.h&quot; headers has handy structs and offsets defined for each register block. And instead of doing bit shifting, the bitmasks for each bitfield/s is/are defined by macros explicitly. Take some time to read the <code>stm32f401xe.h</code> header file. </p> <p>Note that we have not used any of the STM32Cube HAL drivers. We could have done the above using the SPI framework, which is a subset of STM32Cube, or the CMSIS framework which is an ARM specific framework.</p> <div class=page-foot > <div class=copyright > &copy; Ali AlSaibie, PhD. Last modified: April 23, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div>